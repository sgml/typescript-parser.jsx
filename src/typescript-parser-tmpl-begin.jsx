native __fake__ class _SyntaxKind {
    function __native_index_operator__(index : int) : string;
    __readonly__ var None : int;
    __readonly__ var List : int;
    __readonly__ var SeparatedList : int;
    __readonly__ var TriviaList : int;

    __readonly__ var WhitespaceTrivia : int;
    __readonly__ var NewLineTrivia : int;
    __readonly__ var MultiLineCommentTrivia : int;
    __readonly__ var SingleLineCommentTrivia : int;
    __readonly__ var SkippedTokenTrivia : int;

    __readonly__ var ErrorToken : int;
    __readonly__ var EndOfFileToken : int;

    __readonly__ var IdentifierName : int;

    __readonly__ var RegularExpressionLiteral : int;
    __readonly__ var NumericLiteral : int;
    __readonly__ var StringLiteral : int;

    __readonly__ var BreakKeyword : int;
    __readonly__ var CaseKeyword : int;
    __readonly__ var CatchKeyword : int;
    __readonly__ var ContinueKeyword : int;
    __readonly__ var DebuggerKeyword : int;
    __readonly__ var DefaultKeyword : int;
    __readonly__ var DeleteKeyword : int;
    __readonly__ var DoKeyword : int;
    __readonly__ var ElseKeyword : int;
    __readonly__ var FalseKeyword : int;
    __readonly__ var FinallyKeyword : int;
    __readonly__ var ForKeyword : int;
    __readonly__ var FunctionKeyword : int;
    __readonly__ var IfKeyword : int;
    __readonly__ var InKeyword : int;
    __readonly__ var InstanceOfKeyword : int;
    __readonly__ var NewKeyword : int;
    __readonly__ var NullKeyword : int;
    __readonly__ var ReturnKeyword : int;
    __readonly__ var SwitchKeyword : int;
    __readonly__ var ThisKeyword : int;
    __readonly__ var ThrowKeyword : int;
    __readonly__ var TrueKeyword : int;
    __readonly__ var TryKeyword : int;
    __readonly__ var TypeOfKeyword : int;
    __readonly__ var VarKeyword : int;
    __readonly__ var VoidKeyword : int;
    __readonly__ var WhileKeyword : int;
    __readonly__ var WithKeyword : int;

    __readonly__ var ClassKeyword : int;
    __readonly__ var ConstKeyword : int;
    __readonly__ var EnumKeyword : int;
    __readonly__ var ExportKeyword : int;
    __readonly__ var ExtendsKeyword : int;
    __readonly__ var ImportKeyword : int;
    __readonly__ var SuperKeyword : int;

    __readonly__ var ImplementsKeyword : int;
    __readonly__ var InterfaceKeyword : int;
    __readonly__ var LetKeyword : int;
    __readonly__ var PackageKeyword : int;
    __readonly__ var PrivateKeyword : int;
    __readonly__ var ProtectedKeyword : int;
    __readonly__ var PublicKeyword : int;
    __readonly__ var StaticKeyword : int;
    __readonly__ var YieldKeyword : int;

    __readonly__ var AnyKeyword : int;
    __readonly__ var BooleanKeyword : int;
    __readonly__ var ConstructorKeyword : int;
    __readonly__ var DeclareKeyword : int;
    __readonly__ var GetKeyword : int;
    __readonly__ var ModuleKeyword : int;
    __readonly__ var RequireKeyword : int;
    __readonly__ var NumberKeyword : int;
    __readonly__ var SetKeyword : int;
    __readonly__ var StringKeyword : int;

    __readonly__ var OpenBraceToken : int;
    __readonly__ var CloseBraceToken : int;
    __readonly__ var OpenParenToken : int;
    __readonly__ var CloseParenToken : int;
    __readonly__ var OpenBracketToken : int;
    __readonly__ var CloseBracketToken : int;
    __readonly__ var DotToken : int;
    __readonly__ var DotDotDotToken : int;
    __readonly__ var SemicolonToken : int;
    __readonly__ var CommaToken : int;
    __readonly__ var LessThanToken : int;
    __readonly__ var GreaterThanToken : int;
    __readonly__ var LessThanEqualsToken : int;
    __readonly__ var GreaterThanEqualsToken : int;
    __readonly__ var EqualsEqualsToken : int;
    __readonly__ var EqualsGreaterThanToken : int;
    __readonly__ var ExclamationEqualsToken : int;
    __readonly__ var EqualsEqualsEqualsToken : int;
    __readonly__ var ExclamationEqualsEqualsToken : int;
    __readonly__ var PlusToken : int;
    __readonly__ var MinusToken : int;
    __readonly__ var AsteriskToken : int;
    __readonly__ var PercentToken : int;
    __readonly__ var PlusPlusToken : int;
    __readonly__ var MinusMinusToken : int;
    __readonly__ var LessThanLessThanToken : int;
    __readonly__ var GreaterThanGreaterThanToken : int;
    __readonly__ var GreaterThanGreaterThanGreaterThanToken : int;
    __readonly__ var AmpersandToken : int;
    __readonly__ var BarToken : int;
    __readonly__ var CaretToken : int;
    __readonly__ var ExclamationToken : int;
    __readonly__ var TildeToken : int;
    __readonly__ var AmpersandAmpersandToken : int;
    __readonly__ var BarBarToken : int;
    __readonly__ var QuestionToken : int;
    __readonly__ var ColonToken : int;
    __readonly__ var EqualsToken : int;
    __readonly__ var PlusEqualsToken : int;
    __readonly__ var MinusEqualsToken : int;
    __readonly__ var AsteriskEqualsToken : int;
    __readonly__ var PercentEqualsToken : int;
    __readonly__ var LessThanLessThanEqualsToken : int;
    __readonly__ var GreaterThanGreaterThanEqualsToken : int;
    __readonly__ var GreaterThanGreaterThanGreaterThanEqualsToken : int;
    __readonly__ var AmpersandEqualsToken : int;
    __readonly__ var BarEqualsToken : int;
    __readonly__ var CaretEqualsToken : int;
    __readonly__ var SlashToken : int;
    __readonly__ var SlashEqualsToken : int;

    __readonly__ var SourceUnit : int;

    __readonly__ var QualifiedName : int;

    __readonly__ var ObjectType : int;
    __readonly__ var FunctionType : int;
    __readonly__ var ArrayType : int;
    __readonly__ var ConstructorType : int;
    __readonly__ var GenericType : int;
    __readonly__ var TypeQuery : int;

    __readonly__ var InterfaceDeclaration : int;
    __readonly__ var FunctionDeclaration : int;
    __readonly__ var ModuleDeclaration : int;
    __readonly__ var ClassDeclaration : int;
    __readonly__ var EnumDeclaration : int;
    __readonly__ var ImportDeclaration : int;
    __readonly__ var ExportAssignment : int;

    __readonly__ var MemberFunctionDeclaration : int;
    __readonly__ var MemberVariableDeclaration : int;
    __readonly__ var ConstructorDeclaration : int;
    __readonly__ var IndexMemberDeclaration : int;

    __readonly__ var GetAccessor : int;
    __readonly__ var SetAccessor : int;

    __readonly__ var PropertySignature : int;
    __readonly__ var CallSignature : int;
    __readonly__ var ConstructSignature : int;
    __readonly__ var IndexSignature : int;
    __readonly__ var MethodSignature : int;

    __readonly__ var Block : int;
    __readonly__ var IfStatement : int;
    __readonly__ var VariableStatement : int;
    __readonly__ var ExpressionStatement : int;
    __readonly__ var ReturnStatement : int;
    __readonly__ var SwitchStatement : int;
    __readonly__ var BreakStatement : int;
    __readonly__ var ContinueStatement : int;
    __readonly__ var ForStatement : int;
    __readonly__ var ForInStatement : int;
    __readonly__ var EmptyStatement : int;
    __readonly__ var ThrowStatement : int;
    __readonly__ var WhileStatement : int;
    __readonly__ var TryStatement : int;
    __readonly__ var LabeledStatement : int;
    __readonly__ var DoStatement : int;
    __readonly__ var DebuggerStatement : int;
    __readonly__ var WithStatement : int;

    __readonly__ var PlusExpression : int;
    __readonly__ var NegateExpression : int;
    __readonly__ var BitwiseNotExpression : int;
    __readonly__ var LogicalNotExpression : int;
    __readonly__ var PreIncrementExpression : int;
    __readonly__ var PreDecrementExpression : int;
    __readonly__ var DeleteExpression : int;
    __readonly__ var TypeOfExpression : int;
    __readonly__ var VoidExpression : int;
    __readonly__ var CommaExpression : int;
    __readonly__ var AssignmentExpression : int;
    __readonly__ var AddAssignmentExpression : int;
    __readonly__ var SubtractAssignmentExpression : int;
    __readonly__ var MultiplyAssignmentExpression : int;
    __readonly__ var DivideAssignmentExpression : int;
    __readonly__ var ModuloAssignmentExpression : int;
    __readonly__ var AndAssignmentExpression : int;
    __readonly__ var ExclusiveOrAssignmentExpression : int;
    __readonly__ var OrAssignmentExpression : int;
    __readonly__ var LeftShiftAssignmentExpression : int;
    __readonly__ var SignedRightShiftAssignmentExpression : int;
    __readonly__ var UnsignedRightShiftAssignmentExpression : int;
    __readonly__ var ConditionalExpression : int;
    __readonly__ var LogicalOrExpression : int;
    __readonly__ var LogicalAndExpression : int;
    __readonly__ var BitwiseOrExpression : int;
    __readonly__ var BitwiseExclusiveOrExpression : int;
    __readonly__ var BitwiseAndExpression : int;
    __readonly__ var EqualsWithTypeConversionExpression : int;
    __readonly__ var NotEqualsWithTypeConversionExpression : int;
    __readonly__ var EqualsExpression : int;
    __readonly__ var NotEqualsExpression : int;
    __readonly__ var LessThanExpression : int;
    __readonly__ var GreaterThanExpression : int;
    __readonly__ var LessThanOrEqualExpression : int;
    __readonly__ var GreaterThanOrEqualExpression : int;
    __readonly__ var InstanceOfExpression : int;
    __readonly__ var InExpression : int;
    __readonly__ var LeftShiftExpression : int;
    __readonly__ var SignedRightShiftExpression : int;
    __readonly__ var UnsignedRightShiftExpression : int;
    __readonly__ var MultiplyExpression : int;
    __readonly__ var DivideExpression : int;
    __readonly__ var ModuloExpression : int;
    __readonly__ var AddExpression : int;
    __readonly__ var SubtractExpression : int;
    __readonly__ var PostIncrementExpression : int;
    __readonly__ var PostDecrementExpression : int;
    __readonly__ var MemberAccessExpression : int;
    __readonly__ var InvocationExpression : int;
    __readonly__ var ArrayLiteralExpression : int;
    __readonly__ var ObjectLiteralExpression : int;
    __readonly__ var ObjectCreationExpression : int;
    __readonly__ var ParenthesizedExpression : int;
    __readonly__ var ParenthesizedArrowFunctionExpression : int;
    __readonly__ var SimpleArrowFunctionExpression : int;
    __readonly__ var CastExpression : int;
    __readonly__ var ElementAccessExpression : int;
    __readonly__ var FunctionExpression : int;
    __readonly__ var OmittedExpression : int;

    __readonly__ var VariableDeclaration : int;
    __readonly__ var VariableDeclarator : int;

    __readonly__ var ArgumentList : int;
    __readonly__ var ParameterList : int;
    __readonly__ var TypeArgumentList : int;
    __readonly__ var TypeParameterList : int;

    __readonly__ var ExtendsHeritageClause : int;
    __readonly__ var ImplementsHeritageClause : int;
    __readonly__ var EqualsValueClause : int;
    __readonly__ var CaseSwitchClause : int;
    __readonly__ var DefaultSwitchClause : int;
    __readonly__ var ElseClause : int;
    __readonly__ var CatchClause : int;
    __readonly__ var FinallyClause : int;

    __readonly__ var TypeParameter : int;
    __readonly__ var Constraint : int;

    __readonly__ var SimplePropertyAssignment : int;
    __readonly__ var FunctionPropertyAssignment : int;

    __readonly__ var Parameter : int;
    __readonly__ var EnumElement : int;
    __readonly__ var TypeAnnotation : int;
    __readonly__ var ExternalModuleReference : int;
    __readonly__ var ModuleNameModuleReference : int;
    __readonly__ var Last : int;

    __readonly__ var FirstStandardKeyword : int;
    __readonly__ var LastStandardKeyword : int;

    __readonly__ var FirstFutureReservedKeyword : int;
    __readonly__ var LastFutureReservedKeyword : int;

    __readonly__ var FirstFutureReservedStrictKeyword : int;
    __readonly__ var LastFutureReservedStrictKeyword : int;

    __readonly__ var FirstTypeScriptKeyword : int;
    __readonly__ var LastTypeScriptKeyword : int;

    __readonly__ var FirstKeyword : int;
    __readonly__ var LastKeyword : int;

    __readonly__ var FirstToken : int;
    __readonly__ var LastToken : int;

    __readonly__ var FirstPunctuation : int;
    __readonly__ var LastPunctuation : int;

    __readonly__ var FirstFixedWidth : int;
    __readonly__ var LastFixedWidth : int;

    __readonly__ var FirstTrivia : int;
    __readonly__ var LastTrivia : int;
}

native class TypeScript {
    static const SyntaxKind : _SyntaxKind;

    class LineAndCharacter {
        var line : int;
        var character : int;
    }

    class ITypeSyntax extends TypeScript.ISyntaxNodeOrToken {
    }

    class INameSyntax extends TypeScript.ITypeSyntax {
    }

    class IModuleReferenceSyntax extends TypeScript.SyntaxNode {
        function isModuleReference(): boolean;
    }

    class ISyntaxToken extends TypeScript.ISyntaxNodeOrToken {
        var tokenKind : int;

        function text() : string;

        function value() : variant;
        function valueText() : string;

        function hasLeadingTrivia() : boolean;
        function hasLeadingComment() : boolean;
        function hasLeadingNewLine() : boolean;
        function hasLeadingSkippedText() : boolean;

        function hasTrailingTrivia() : boolean;
        function hasTrailingComment() : boolean;
        function hasTrailingNewLine() : boolean;
        function hasTrailingSkippedText() : boolean;

        function hasSkippedToken() : boolean;

        function clone() : TypeScript.ISyntaxToken;
    }

    class ISyntaxElement {
        function kind() : int;

        function isNode() : boolean;
        function isToken() : boolean;
        function isList() : boolean;
        function isSeparatedList() : boolean;

        function childCount() : int;
        function childAt(index: int) : TypeScript.ISyntaxElement;

        function isTypeScriptSpecific() : boolean;

        function isIncrementallyUnusable() : boolean;
        function fullWidth() : int;
        function width() : int;
        function fullText() : string;

        function leadingTrivia() : TypeScript.ISyntaxTriviaList;
        function trailingTrivia() : TypeScript.ISyntaxTriviaList;

        function leadingTriviaWidth() : int;
        function trailingTriviaWidth() : int;

        function firstToken() : TypeScript.ISyntaxToken;
        function lastToken() : TypeScript.ISyntaxToken;

        function collectTextElements(elements: string[]) : void;
    }

    class ISyntaxNodeOrToken extends TypeScript.ISyntaxElement {
        //accept(visitor: ISyntaxVisitor): any;
    }

    class ISyntaxList extends TypeScript.ISyntaxElement {
        function childAt(index: number): TypeScript.ISyntaxNodeOrToken;
        function toArray(): TypeScript.ISyntaxNodeOrToken[];
        function insertChildrenInto(array: TypeScript.ISyntaxElement[], index: number): void;
    }

    class ISyntaxTrivia {
        function kind() : int;
        function isWhitespace() : boolean;
        function isComment() : boolean;
        function isNewLine() : boolean;
        function isSkippedToken() : boolean;
        function fullWidth() : int;
        function fullText() : string;
        function skippedToken() : TypeScript.ISyntaxToken;
    }

    class ISyntaxTriviaList {
        function count() : int;
        function syntaxTriviaAt(index : int) : TypeScript.ISyntaxTrivia;
        function fullWidth() : int;
        function fullText() : string;
        function hasComment() : boolean;
        function hasNewLine() : boolean;
        function hasSkippedToken() : boolean;
        function last() : TypeScript.ISyntaxTrivia;
        function toArray() : TypeScript.ISyntaxTrivia[];
        function concat(trivia : TypeScript.ISyntaxTriviaList) : TypeScript.ISyntaxTriviaList;
        function collectTextElements(elements : string[]) : void;
    }

    class IExpressionSyntax extends TypeScript.ISyntaxNodeOrToken {
        function isExpression() : boolean;
    }

    class IModuleElementSyntax extends TypeScript.SyntaxNode {
    }

    class IPostfixExpressionSyntax extends TypeScript.IUnaryExpressionSyntax {
        function isPostfixExpression() : boolean;
    }

    class IMemberExpressionSyntax extends TypeScript.IPostfixExpressionSyntax {
        function isMemberExpression() : boolean;
    }

    class ISeparatedSyntaxList extends TypeScript.ISyntaxElement {
        function toArray() : TypeScript.ISyntaxNodeOrToken[];
        function toNonSeparatorArray() : TypeScript.ISyntaxNodeOrToken[];
        function separatorCount() : int;
        function separatorAt(index : int) : TypeScript.ISyntaxToken;
        function nonSeparatorCount() : int;
        function nonSeparatorAt(index : int) : TypeScript.ISyntaxNodeOrToken;
        function insertChildrenInto(array : TypeScript.ISyntaxElement[], index : int) : void;
    }

    class IStatementSyntax extends TypeScript.IModuleElementSyntax {
    }

    class IUnaryExpressionSyntax extends TypeScript.IExpressionSyntax {
        function isUnaryExpression() : boolean;
    }

    class PositionedToken {
        function token() : TypeScript.ISyntaxToken;
        function previousToken(includeSkippedTokens : boolean = false) : TypeScript.PositionedToken;
        function nextToken(includeSkippedTokens : boolean = false) : TypeScript.PositionedToken;
    }

    class LineMap {
        static const empty : TypeScript.LineMap;
        function toJSON() : variant;
        function equals(other : TypeScript.LineMap) : boolean;
        function lineStarts() : int[];
        function lineCount() : int;
        function getPosition(line : int, character : int) : int;
        function getLineNumberFromPosition(position : int) : int;
        function getLineStartPosition(lineNumber : int) : int;
        function fillLineAndCharacterFromPosition(position : int, lineAndCharacter : TypeScript.LineAndCharacter) : void;
        function getLineAndCharacterFromPosition(position : int) : TypeScript.LineAndCharacter;
    }

    class SyntaxNode extends TypeScript.ISyntaxNodeOrToken {
        function insertChildrenInto(array : TypeScript.ISyntaxElement[], index : int) : void;
        function toJSON() : variant;
        //function accept(visitor : TypeScript.ISyntaxVisitor) : variant;
        function replaceToken(token1 : TypeScript.ISyntaxToken, token2 : TypeScript.ISyntaxToken) : TypeScript.SyntaxNode;
        function hasLeadingTrivia() : boolean;
        function hasTrailingTrivia() : boolean;
        function parsedInStrictMode() : boolean;
        function findToken(position : int, includeSkippedTokens : boolean = false) : TypeScript.PositionedToken;
        function findTokenOnLeft(position : number, includeSkippedTokens : boolean = false) : TypeScript.PositionedToken;
        function findCompleteTokenOnLeft(position : number, includeSkippedTokens : boolean = false) : TypeScript.PositionedToken;
        function isModuleElement() : boolean;
        function isClassElement() : boolean;
        function isTypeMember() : boolean;
        function isStatement() : boolean;
        function isExpression() : boolean;
        function isSwitchClause() : boolean;
        function structuralEquals(node : TypeScript.SyntaxNode) : boolean;
    }

    class SourceUnitSyntax extends TypeScript.SyntaxNode {
        var moduleElements : TypeScript.ISyntaxList;
        var endOfFileToken : TypeScript.ISyntaxToken;
    }

    class ExternalModuleReferenceSyntax extends TypeScript.SyntaxNode {
        var requireKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var stringLiteral : TypeScript.ISyntaxToken;
        var closeParenToken : TypeScript.ISyntaxToken;

        function isModuleReference() : boolean;
    }

    class ModuleNameModuleReferenceSyntax extends TypeScript.SyntaxNode {
        var moduleName : TypeScript.INameSyntax;
        function isModuleReference() : boolean;
    }

    class ImportDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var importKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var equalsToken : TypeScript.ISyntaxToken;
        var moduleReference : TypeScript.IModuleReferenceSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ExportAssignmentSyntax extends TypeScript.SyntaxNode {
        var exportKeyword : TypeScript.ISyntaxToken;
        var equalsToken : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ClassDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var classKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var typeParameterList : TypeScript.TypeParameterListSyntax;
        var heritageClauses : TypeScript.ISyntaxList;
        var openBraceToken : TypeScript.ISyntaxToken;
        var classElements : TypeScript.ISyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;
    }

    class InterfaceDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var interfaceKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var typeParameterList : TypeScript.TypeParameterListSyntax;
        var heritageClauses : TypeScript.ISyntaxList;
        var body : TypeScript.ObjectTypeSyntax;
    }

    class HeritageClauseSyntax extends TypeScript.SyntaxNode {
        var extendsOrImplementsKeyword : TypeScript.ISyntaxToken;
        var typeNames : TypeScript.ISeparatedSyntaxList;
    }

    class ModuleDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var moduleKeyword : TypeScript.ISyntaxToken;
        var name : TypeScript.INameSyntax;
        var stringLiteral : TypeScript.ISyntaxToken;
        var openBraceToken : TypeScript.ISyntaxToken;
        var moduleElements : TypeScript.ISyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;
    }

    class FunctionDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var functionKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;
        var block : TypeScript.BlockSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class VariableStatementSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var variableDeclaration : TypeScript.VariableDeclarationSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class VariableDeclarationSyntax extends TypeScript.SyntaxNode {
        var varKeyword : TypeScript.ISyntaxToken;
        var variableDeclarators : TypeScript.ISeparatedSyntaxList;
    }

    class VariableDeclaratorSyntax extends TypeScript.SyntaxNode {
        var propertyName : TypeScript.ISyntaxToken;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
        var equalsValueClause : TypeScript.EqualsValueClauseSyntax;
    }

    class EqualsValueClauseSyntax extends TypeScript.SyntaxNode {
        var equalsToken : TypeScript.ISyntaxToken;
        var value : TypeScript.IExpressionSyntax;
    }

    class PrefixUnaryExpressionSyntax extends TypeScript.SyntaxNode {
        var operatorToken : TypeScript.ISyntaxToken;
        var operand : TypeScript.IUnaryExpressionSyntax;

        function isUnaryExpression() : boolean;
    }

    class ArrayLiteralExpressionSyntax extends TypeScript.SyntaxNode {
        var openBracketToken : TypeScript.ISyntaxToken;
        var expressions : TypeScript.ISeparatedSyntaxList;
        var closeBracketToken : TypeScript.ISyntaxToken;

        function isPrimaryExpression() : boolean;
        function isMemberExpression() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class OmittedExpressionSyntax extends TypeScript.SyntaxNode {
    }

    class ParenthesizedExpressionSyntax extends TypeScript.SyntaxNode {
        var openParenToken : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;

        function isPrimaryExpression() : boolean;
        function isMemberExpression() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class SimpleArrowFunctionExpressionSyntax extends TypeScript.SyntaxNode {
        var identifier : TypeScript.ISyntaxToken;
        var equalsGreaterThanToken : TypeScript.ISyntaxToken;
        var block : TypeScript.BlockSyntax;
        var expression : TypeScript.IExpressionSyntax;

        function isArrowFunctionExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class ParenthesizedArrowFunctionExpressionSyntax extends TypeScript.SyntaxNode {
        var callSignature : TypeScript.CallSignatureSyntax;
        var equalsGreaterThanToken : TypeScript.ISyntaxToken;
        var block : TypeScript.BlockSyntax;
        var expression : TypeScript.IExpressionSyntax;

        function isArrowFunctionExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class QualifiedNameSyntax extends TypeScript.SyntaxNode {
        var left : TypeScript.INameSyntax;
        var dotToken : TypeScript.ISyntaxToken;
        var right : TypeScript.ISyntaxToken;

        function isName() : boolean;
        function isType() : boolean;
    }

    class TypeArgumentListSyntax extends TypeScript.SyntaxNode {
        var lessThanToken : TypeScript.ISyntaxToken;
        var typeArguments : TypeScript.ISeparatedSyntaxList;
        var greaterThanToken : TypeScript.ISyntaxToken;
    }

    class ConstructorTypeSyntax extends TypeScript.SyntaxNode {
        var newKeyword : TypeScript.ISyntaxToken;
        var typeParameterList : TypeScript.TypeParameterListSyntax;
        var parameterList : TypeScript.ParameterListSyntax;
        var equalsGreaterThanToken : TypeScript.ISyntaxToken;
        var type : TypeScript.ITypeSyntax;

        function isType() : boolean;
    }

    class FunctionTypeSyntax extends TypeScript.SyntaxNode {
        var typeParameterList : TypeScript.TypeParameterListSyntax;
        var parameterList : TypeScript.ParameterListSyntax;
        var equalsGreaterThanToken : TypeScript.ISyntaxToken;
        var type : TypeScript.ITypeSyntax;

        function isType() : boolean;
    }

    class ObjectTypeSyntax extends TypeScript.SyntaxNode {
        var openBraceToken : TypeScript.ISyntaxToken;
        var typeMembers : TypeScript.ISeparatedSyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;

        function isType() : boolean;
    }

    class ArrayTypeSyntax extends TypeScript.SyntaxNode {
        var type : TypeScript.ITypeSyntax;
        var openBracketToken : TypeScript.ISyntaxToken;
        var closeBracketToken : TypeScript.ISyntaxToken;

        function isType() : boolean;
    }

    class GenericTypeSyntax extends TypeScript.SyntaxNode {
        var name : TypeScript.INameSyntax;
        var typeArgumentList : TypeScript.TypeArgumentListSyntax;

        function isType() : boolean;
    }

    class TypeQuerySyntax extends TypeScript.SyntaxNode {
        var typeOfKeyword : TypeScript.ISyntaxToken;
        var name : TypeScript.INameSyntax;

        function isType() : boolean;
    }

    class TypeAnnotationSyntax extends TypeScript.SyntaxNode {
        var colonToken : TypeScript.ISyntaxToken;
        var type : TypeScript.ITypeSyntax;
    }

    class BlockSyntax extends TypeScript.SyntaxNode {
        var openBraceToken : TypeScript.ISyntaxToken;
        var statements : TypeScript.ISyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;
    }

    class ParameterSyntax extends TypeScript.SyntaxNode {
        var dotDotDotToken : TypeScript.ISyntaxToken;
        var modifiers : TypeScript.ISyntaxList;
        var identifier : TypeScript.ISyntaxToken;
        var questionToken : TypeScript.ISyntaxToken;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
        var equalsValueClause : TypeScript.EqualsValueClauseSyntax;
    }

    class MemberAccessExpressionSyntax extends TypeScript.SyntaxNode {
        var expression : TypeScript.IExpressionSyntax;
        var dotToken : TypeScript.ISyntaxToken;
        var name : TypeScript.ISyntaxToken;

        function isMemberExpression() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class PostfixUnaryExpressionSyntax extends TypeScript.SyntaxNode {
        var operand : TypeScript.IMemberExpressionSyntax;
        var operatorToken : TypeScript.ISyntaxToken;

        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class ElementAccessExpressionSyntax extends TypeScript.SyntaxNode {
        var expression : TypeScript.IExpressionSyntax;
        var openBracketToken : TypeScript.ISyntaxToken;
        var argumentExpression : TypeScript.IExpressionSyntax;
        var closeBracketToken : TypeScript.ISyntaxToken;

        function isMemberExpression() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class InvocationExpressionSyntax extends TypeScript.SyntaxNode {
        var expression : TypeScript.IExpressionSyntax;
        var argumentList : TypeScript.ArgumentListSyntax;

        function isMemberExpression() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class ArgumentListSyntax extends TypeScript.SyntaxNode {
        var typeArgumentList : TypeScript.TypeArgumentListSyntax;
        var openParenToken : TypeScript.ISyntaxToken;
        var arguments : TypeScript.ISeparatedSyntaxList;
        var closeParenToken : TypeScript.ISyntaxToken;
    }

    class BinaryExpressionSyntax extends TypeScript.SyntaxNode {
        var left : TypeScript.IExpressionSyntax;
        var operatorToken : TypeScript.ISyntaxToken;
        var right : TypeScript.IExpressionSyntax;
    }

    class ConditionalExpressionSyntax extends TypeScript.SyntaxNode {
        var condition : TypeScript.IExpressionSyntax;
        var questionToken : TypeScript.ISyntaxToken;
        var whenTrue : TypeScript.IExpressionSyntax;
        var colonToken : TypeScript.ISyntaxToken;
        var whenFalse : TypeScript.IExpressionSyntax;
    }

    class ConstructSignatureSyntax extends TypeScript.SyntaxNode {
        var newKeyword : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;
    }

    class MethodSignatureSyntax extends TypeScript.SyntaxNode {
        var propertyName : TypeScript.ISyntaxToken;
        var questionToken : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;

    }

    class IndexSignatureSyntax extends TypeScript.SyntaxNode {
        var openBracketToken : TypeScript.ISyntaxToken;
        var parameter : TypeScript.ParameterSyntax;
        var closeBracketToken : TypeScript.ISyntaxToken;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
    }

    class PropertySignatureSyntax extends TypeScript.SyntaxNode {
        var propertyName : TypeScript.ISyntaxToken;
        var questionToken : TypeScript.ISyntaxToken;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
    }

    class CallSignatureSyntax extends TypeScript.SyntaxNode {
        var typeParameterList : TypeScript.TypeParameterListSyntax;
        var parameterList : TypeScript.ParameterListSyntax;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
    }

    class ParameterListSyntax extends TypeScript.SyntaxNode {
        var openParenToken : TypeScript.ISyntaxToken;
        var parameters : TypeScript.ISeparatedSyntaxList;
        var closeParenToken : TypeScript.ISyntaxToken;
    }

    class TypeParameterListSyntax extends TypeScript.SyntaxNode {
        var lessThanToken : TypeScript.ISyntaxToken;
        var typeParameters : TypeScript.ISeparatedSyntaxList;
        var greaterThanToken : TypeScript.ISyntaxToken;
    }

    class TypeParameterSyntax extends TypeScript.SyntaxNode {
        var identifier : TypeScript.ISyntaxToken;
        var constraint : TypeScript.ConstraintSyntax;
    }

    class ConstraintSyntax extends TypeScript.SyntaxNode {
        var extendsKeyword : TypeScript.ISyntaxToken;
        var type : TypeScript.ITypeSyntax;
    }

    class ElseClauseSyntax extends TypeScript.SyntaxNode {
        var elseKeyword : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;
    }

    class IfStatementSyntax extends TypeScript.SyntaxNode {
        var ifKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var condition : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;
        var elseClause : TypeScript.ElseClauseSyntax;
    }

    class ExpressionStatementSyntax extends TypeScript.SyntaxNode {
        var expression : TypeScript.IExpressionSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ConstructorDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var constructorKeyword : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;
        var block : TypeScript.BlockSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class MemberFunctionDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var propertyName : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;
        var block : TypeScript.BlockSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;

        function isMemberDeclaration() : boolean;
    }

    class GetAccessorSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var getKeyword : TypeScript.ISyntaxToken;
        var propertyName : TypeScript.ISyntaxToken;
        var parameterList : TypeScript.ParameterListSyntax;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
        var block : TypeScript.BlockSyntax;

        function isMemberDeclaration() : boolean;
        function isPropertyAssignment() : boolean;
    }

    class SetAccessorSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var setKeyword : TypeScript.ISyntaxToken;
        var propertyName : TypeScript.ISyntaxToken;
        var parameterList : TypeScript.ParameterListSyntax;
        var block : TypeScript.BlockSyntax;

        function isMemberDeclaration() : boolean;
        function isPropertyAssignment() : boolean;
    }

    class MemberVariableDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var variableDeclarator : TypeScript.VariableDeclaratorSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;

        function isMemberDeclaration() : boolean;
    }

    class IndexMemberDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var indexSignature : TypeScript.IndexSignatureSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ThrowStatementSyntax extends TypeScript.SyntaxNode {
        var throwKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ReturnStatementSyntax extends TypeScript.SyntaxNode {
        var returnKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ObjectCreationExpressionSyntax extends TypeScript.SyntaxNode {
        var newKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IMemberExpressionSyntax;
        var argumentList : TypeScript.ArgumentListSyntax;

        function isMemberDeclaration() : boolean;
        function isPropertyAssignment() : boolean;
        function isUnaryExpression() : boolean;
    }

    class SwitchStatementSyntax extends TypeScript.SyntaxNode {
        var switchKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var openBraceToken : TypeScript.ISyntaxToken;
        var switchClauses : TypeScript.ISyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;
    }

    class CaseSwitchClauseSyntax extends TypeScript.SyntaxNode {
        var caseKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;
        var colonToken : TypeScript.ISyntaxToken;
        var statements : TypeScript.ISyntaxList;
    }

    class DefaultSwitchClauseSyntax extends TypeScript.SyntaxNode {
        var defaultKeyword : TypeScript.ISyntaxToken;
        var colonToken : TypeScript.ISyntaxToken;
        var statements : TypeScript.ISyntaxList;
    }

    class BreakStatementSyntax extends TypeScript.SyntaxNode {
        var breakKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ContinueStatementSyntax extends TypeScript.SyntaxNode {
        var continueKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class ForStatementSyntax extends TypeScript.SyntaxNode {
        var forKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var variableDeclaration : TypeScript.VariableDeclarationSyntax;
        var initializer : TypeScript.IExpressionSyntax;
        var firstSemicolonToken : TypeScript.ISyntaxToken;
        var condition : TypeScript.IExpressionSyntax;
        var secondSemicolonToken : TypeScript.ISyntaxToken;
        var incrementor : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;

        function isIterationStatement() : boolean;
    }

    class ForInStatementSyntax extends TypeScript.SyntaxNode {
        var forKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var variableDeclaration : TypeScript.VariableDeclarationSyntax;
        var left : TypeScript.IExpressionSyntax;
        var inKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;

        function isIterationStatement() : boolean;
    }

    class WhileStatementSyntax extends TypeScript.SyntaxNode {
        var whileKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var condition : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;

        function isIterationStatement() : boolean;
    }

    class WithStatementSyntax extends TypeScript.SyntaxNode {
        var withKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var condition : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;
    }

    class EnumDeclarationSyntax extends TypeScript.SyntaxNode {
        var modifiers : TypeScript.ISyntaxList;
        var enumKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var openBraceToken : TypeScript.ISyntaxToken;
        var enumElements : TypeScript.ISeparatedSyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;
    }

    class EnumElementSyntax extends TypeScript.SyntaxNode {
        var propertyName : TypeScript.ISyntaxToken;
        var equalsValueClause : TypeScript.EqualsValueClauseSyntax;
    }

    class CastExpressionSyntax extends TypeScript.SyntaxNode {
        var lessThanToken : TypeScript.ISyntaxToken;
        var type : TypeScript.ITypeSyntax;
        var greaterThanToken : TypeScript.ISyntaxToken;
        var expression : TypeScript.IUnaryExpressionSyntax;

        function isUnaryExpression() : boolean;
    }

    class ObjectLiteralExpressionSyntax extends TypeScript.SyntaxNode {
        var openBraceToken : TypeScript.ISyntaxToken;
        var propertyAssignments : TypeScript.ISeparatedSyntaxList;
        var closeBraceToken : TypeScript.ISyntaxToken;

        function isPrimaryExpression() : boolean;
        function isMemberDeclaration() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class SimplePropertyAssignmentSyntax extends TypeScript.SyntaxNode {
        var propertyName : TypeScript.ISyntaxToken;
        var colonToken : TypeScript.ISyntaxToken;
        var expression : TypeScript.IExpressionSyntax;

        function isPropertyAssignment() : boolean;
    }

    class FunctionPropertyAssignmentSyntax extends TypeScript.SyntaxNode {
        var propertyName : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;
        var block : TypeScript.BlockSyntax;

        function isPropertyAssignment() : boolean;
    }

    class FunctionExpressionSyntax extends TypeScript.SyntaxNode {
        var functionKeyword : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var callSignature : TypeScript.CallSignatureSyntax;
        var block : TypeScript.BlockSyntax;

        function isPrimaryExpression() : boolean;
        function isMemberDeclaration() : boolean;
        function isPostfixExpression() : boolean;
        function isUnaryExpression() : boolean;
    }

    class EmptyStatementSyntax extends TypeScript.SyntaxNode {
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class TryStatementSyntax extends TypeScript.SyntaxNode {
        var tryKeyword : TypeScript.ISyntaxToken;
        var block : TypeScript.BlockSyntax;
        var catchClause : TypeScript.CatchClauseSyntax;
        var finallyClause : TypeScript.FinallyClauseSyntax;
    }

    class CatchClauseSyntax extends TypeScript.SyntaxNode {
        var catchKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var identifier : TypeScript.ISyntaxToken;
        var typeAnnotation : TypeScript.TypeAnnotationSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var block : TypeScript.BlockSyntax;
    }

    class FinallyClauseSyntax extends TypeScript.SyntaxNode {
        var finallyKeyword : TypeScript.ISyntaxToken;
        var block : TypeScript.BlockSyntax;
    }

    class LabeledStatementSyntax extends TypeScript.SyntaxNode {
        var identifier : TypeScript.ISyntaxToken;
        var colonToken : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;
    }

    class DoStatementSyntax extends TypeScript.SyntaxNode {
        var doKeyword : TypeScript.ISyntaxToken;
        var statement : TypeScript.IStatementSyntax;
        var whileKeyword : TypeScript.ISyntaxToken;
        var openParenToken : TypeScript.ISyntaxToken;
        var condition : TypeScript.IExpressionSyntax;
        var closeParenToken : TypeScript.ISyntaxToken;
        var semicolonToken : TypeScript.ISyntaxToken;

        function isIterationStatement() : boolean;
    }

    class TypeOfExpressionSyntax extends TypeScript.SyntaxNode {
        var typeOfKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IUnaryExpressionSyntax;

        function isUnaryExpression() : boolean;
    }

    class DeleteExpressionSyntax extends TypeScript.SyntaxNode {
        var deleteKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IUnaryExpressionSyntax;

        function isUnaryExpression() : boolean;
    }

    class VoidExpressionSyntax extends TypeScript.SyntaxNode {
        var voidKeyword : TypeScript.ISyntaxToken;
        var expression : TypeScript.IUnaryExpressionSyntax;

        function isUnaryExpression() : boolean;
    }

    class DebuggerStatementSyntax extends TypeScript.SyntaxNode {
        var debuggerKeyword : TypeScript.ISyntaxToken;
        var semicolonToken : TypeScript.ISyntaxToken;
    }

    class LanguageVersion {
        static const EcmaScript3 = 0;
        static const EcmaScript5 = 1;
    }

    class ParseOptions {
        function toJSON() : variant;
        function languageVersion() : int;
        function allowAutomaticSemicolonInsertion() : boolean;
    }

    class SyntaxTree {
        function toJSON() : variant;
        function sourceUnit() : TypeScript.SourceUnitSyntax;
        function isDeclaration() : boolean;
        //function diagnostics() : Diagnostic[];
        function fileName() : string;
        function lineMap() : TypeScript.LineMap;
        function parseOptions() : TypeScript.ParseOptions;
        function structuralEquals(tree : TypeScript.SyntaxTree) : boolean;
    }

    class Parser {
        static function parse (filename : string, source : string, isdts : boolean = false) : TypeScript.SyntaxTree;
    }
} = """
(function () {
var TypeScript = {};
